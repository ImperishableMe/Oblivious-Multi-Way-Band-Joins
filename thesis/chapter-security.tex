%======================================================================
\chapter{Security Analysis}
%======================================================================

This chapter provides a formal security analysis of our oblivious multi-way band join algorithm. We prove that the algorithm's memory access patterns reveal no information about the input data beyond what is explicitly allowed (table sizes and tree structure). Our proof follows a modular approach, building from simple components to the complete algorithm using the composition theorem for oblivious operations.

%----------------------------------------------------------------------
\section{Security Model and Definitions}
%----------------------------------------------------------------------

We begin by formally defining oblivious operations and stating the composition theorem that underlies our security proof.

\subsection{Oblivious Operations}

\begin{definition}[Oblivious Operation]
An operation $\mathcal{O}: \mathcal{D} \rightarrow \mathcal{D}'$ is \emph{oblivious} if for any two input sequences $X, Y \in \mathcal{D}$ with $|X| = |Y|$, the access patterns $\mathcal{AP}(\mathcal{O}(X))$ and $\mathcal{AP}(\mathcal{O}(Y))$ are identically distributed.
\end{definition}

Intuitively, an oblivious operation accesses memory in a pattern that depends only on the size of the input, not on the actual data values. An adversary observing the memory accesses learns nothing about the data beyond its size.

\subsection{Composition Theorem}

The following theorem, standard in the oblivious algorithms literature, allows us to build complex oblivious algorithms from simple oblivious components:

\begin{theorem}[Sequential Composition]
\label{thm:composition}
If $\mathcal{O}_1: \mathcal{D} \rightarrow \mathcal{D}'$ and $\mathcal{O}_2: \mathcal{D}' \rightarrow \mathcal{D}''$ are oblivious operations, then their sequential composition $(\mathcal{O}_2 \circ \mathcal{O}_1): \mathcal{D} \rightarrow \mathcal{D}''$ defined by $(\mathcal{O}_2 \circ \mathcal{O}_1)(x) = \mathcal{O}_2(\mathcal{O}_1(x))$ is also oblivious.
\end{theorem}

\begin{proof}
For any inputs $x, y \in \mathcal{D}$ with $|x| = |y|$:
\begin{enumerate}
\item $\mathcal{AP}(\mathcal{O}_1(x)) \equiv \mathcal{AP}(\mathcal{O}_1(y))$ since $\mathcal{O}_1$ is oblivious
\item Let $x' = \mathcal{O}_1(x)$ and $y' = \mathcal{O}_1(y)$. Since $\mathcal{O}_1$ is oblivious, $|x'| = |y'|$
\item $\mathcal{AP}(\mathcal{O}_2(x')) \equiv \mathcal{AP}(\mathcal{O}_2(y'))$ since $\mathcal{O}_2$ is oblivious
\item Therefore, $\mathcal{AP}((\mathcal{O}_2 \circ \mathcal{O}_1)(x)) \equiv \mathcal{AP}((\mathcal{O}_2 \circ \mathcal{O}_1)(y))$
\end{enumerate}
Hence, $\mathcal{O}_2 \circ \mathcal{O}_1$ is oblivious.
\end{proof}

\subsection{Security Goal}

Our security goal is to prove the following theorem:

\begin{theorem}[Main Security Theorem]
\label{thm:main-security}
The oblivious multi-way band join algorithm is oblivious. That is, for any two sets of input tables with the same sizes, tree structure, and output size, the memory access patterns are identically distributed.
\end{theorem}

We prove this theorem through a hierarchical approach, starting with individual components and building up to the complete algorithm.

%----------------------------------------------------------------------
\section{Level 1: Base Component Security}
%----------------------------------------------------------------------

We first prove that our custom window functions, comparators, and update functions can be converted to oblivious implementations. Our conversion strategy relies on two key techniques:

\begin{enumerate}
\item \textbf{Arithmetic conversion}: Replace all conditional branches with arithmetic operations using 0/1 predicates. For any condition, we compute a predicate $p \in \{0,1\}$ and use multiplication: $\text{result} = p \cdot \text{value}_{\text{true}} + (1-p) \cdot \text{value}_{\text{false}}$.

\item \textbf{Access pattern uniformity}: Ensure all execution paths access the same memory locations in the same order, regardless of data values.
\end{enumerate}

This approach transforms data-dependent control flow into data-oblivious arithmetic operations, ensuring that the memory access pattern is independent of the input data values.

\subsection{Window Functions}

\begin{lemma}
\label{lem:window-local-sum}
\textsc{WindowComputeLocalSum} (Algorithm~\ref{alg:window-compute-local-sum}) can be converted to an oblivious implementation.
\end{lemma}

\begin{proof}
The function's conditional logic on entry type can be converted to oblivious form:
\begin{enumerate}
\item \textbf{Access pattern}: Always reads $\text{window}[0].\localsum$ and $\text{window}[1].\fieldtype$, $\text{window}[1].\localmult$, and always writes to $\text{window}[1].\localsum$.
\item \textbf{Arithmetic conversion}: The conditional branch becomes:
\begin{align}
\text{is\_source} &= (\text{window}[1].\fieldtype == \typesource) \in \{0,1\} \nonumber \\
\text{window}[1].\localsum &= \text{window}[0].\localsum \nonumber \\
&\quad + \text{is\_source} \cdot \text{window}[1].\localmult \nonumber
\end{align}
\end{enumerate}
This eliminates the conditional branch while preserving functionality: when SOURCE, adds $\localmult$; otherwise adds 0.
\end{proof}

\begin{lemma}
\label{lem:window-local-interval}
\textsc{WindowComputeLocalInterval} (Algorithm~\ref{alg:window-compute-local-interval}) can be converted to an oblivious implementation.
\end{lemma}

\begin{proof}
The function's conditional interval computation can be made oblivious:
\begin{enumerate}
\item \textbf{Access pattern}: Always read $\text{window}[0]$ and $\text{window}[1]$ fields, always write to $\text{window}[1].\localinterval$.
\item \textbf{Arithmetic conversion}: The conditional check becomes:
\begin{align}
\text{is\_pair} &= (\text{window}[0].\fieldtype == \typestart) \nonumber \\
&\quad \cdot (\text{window}[1].\fieldtype == \typeend) \in \{0,1\} \nonumber \\
\text{interval} &= \text{window}[1].\localsum - \text{window}[0].\localsum \nonumber \\
\text{window}[1].\localinterval &= \text{is\_pair} \cdot \text{interval} \nonumber \\
&\quad + (1 - \text{is\_pair}) \cdot \text{window}[1].\localinterval \nonumber
\end{align}
\end{enumerate}
The write always happens (either new interval or preserving existing value).
\end{proof}

\begin{lemma}
\label{lem:window-foreign-sum}
\textsc{WindowComputeForeignSum} (Algorithm~\ref{alg:window-compute-foreign-sum}) can be converted to an oblivious implementation.
\end{lemma}

\begin{proof}
The function's three-way branch can be converted to arithmetic operations:
\begin{enumerate}
\item \textbf{Access pattern}: Always read $\text{window}[0]$ fields and $\text{window}[1]$ fields, always write to $\text{window}[1].\localweight$ and $\text{window}[1].\foreigncumsum$.
\item \textbf{Arithmetic conversion}: The type-based branching becomes:
\begin{align}
\text{is\_start} &= (\text{window}[1].\fieldtype == \typestart) \in \{0,1\} \nonumber \\
\text{is\_end} &= (\text{window}[1].\fieldtype == \typeend) \in \{0,1\} \nonumber \\
\text{is\_source} &= (\text{window}[1].\fieldtype == \typesource) \in \{0,1\} \nonumber \\
\text{weight\_delta} &= \text{is\_start} \cdot \text{window}[1].\localmult \nonumber \\
&\quad - \text{is\_end} \cdot \text{window}[1].\localmult \nonumber \\
\text{window}[1].\localweight &= \text{window}[0].\localweight + \text{weight\_delta} \nonumber \\
\text{safe\_denom} &= \text{is\_source} \cdot \text{window}[0].\localweight + (1 - \text{is\_source}) \cdot 1 \nonumber \\
\text{foreign\_delta} &= \text{is\_source} \cdot (\text{window}[1].\finalmult / \text{safe\_denom}) \nonumber \\
\text{window}[1].\foreigncumsum &= \text{window}[0].\foreigncumsum + \text{foreign\_delta} \nonumber
\end{align}
\end{enumerate}
The safe denominator ensures division is never by zero: it uses the actual weight for SOURCE entries and 1 otherwise.
\end{proof}

\begin{lemma}
\label{lem:window-foreign-interval}
\textsc{WindowComputeForeignInterval} (Algorithm~\ref{alg:window-compute-foreign-interval}) can be converted to an oblivious implementation.
\end{lemma}

\begin{proof}
The function's conditional logic can be made oblivious:
\begin{enumerate}
\item \textbf{Access pattern}: Always read $\text{window}[0]$ and $\text{window}[1]$ fields, always write to $\text{window}[1].\foreigninterval$ and $\text{window}[1].\foreignsum$.
\item \textbf{Arithmetic conversion}: The conditional becomes:
\begin{align}
\text{is\_pair} &= (\text{window}[0].\fieldtype == \typestart) \nonumber \\
&\quad \cdot (\text{window}[1].\fieldtype == \typeend) \in \{0,1\} \nonumber \\
\text{interval} &= \text{window}[1].\foreigncumsum - \text{window}[0].\foreigncumsum \nonumber \\
\text{window}[1].\foreigninterval &= \text{is\_pair} \cdot \text{interval} \nonumber \\
&\quad + (1 - \text{is\_pair}) \cdot \text{window}[1].\foreigninterval \nonumber \\
\text{window}[1].\foreignsum &= \text{is\_pair} \cdot \text{window}[0].\foreigncumsum \nonumber \\
&\quad + (1 - \text{is\_pair}) \cdot \text{window}[1].\foreignsum \nonumber
\end{align}
\end{enumerate}
\end{proof}

\subsection{Comparators}

\begin{lemma}
\label{lem:comparator-join}
\textsc{ComparatorJoinAttr} (Algorithm~\ref{alg:comparator-join-attr}) can be converted to an oblivious implementation.
\end{lemma}

\begin{proof}
The comparator's conditional logic can be made oblivious:
\begin{enumerate}
\item \textbf{Access pattern}: Always read both elements' $\joinattr$, $\fieldtype$, and $\fieldequalitytype$ fields, and always access the precedence table.
\item \textbf{Arithmetic conversion}: Convert the nested conditionals to arithmetic:
\begin{align}
\text{cmp} &= \text{sign}(e_1.\joinattr - e_2.\joinattr) \in \{-1, 0, 1\} \nonumber \\
\text{is\_equal} &= (\text{cmp} == 0) \in \{0,1\} \nonumber \\
p_1 &= \text{GetPrecedence}(e_1.\fieldtype, e_1.\fieldequalitytype) \nonumber \\
p_2 &= \text{GetPrecedence}(e_2.\fieldtype, e_2.\fieldequalitytype) \nonumber \\
\text{prec\_cmp} &= \text{sign}(p_1 - p_2) \in \{-1, 0, 1\} \nonumber \\
\text{result} &= (1 - \text{is\_equal}) \cdot \text{cmp} + \text{is\_equal} \cdot \text{prec\_cmp} \nonumber
\end{align}
\end{enumerate}
The precedence lookup uses both type and equality type fields as indices.
\end{proof}

\begin{lemma}
\label{lem:comparator-pairwise}
\textsc{ComparatorPairwise} (Algorithm~\ref{alg:comparator-pairwise}) can be converted to an oblivious implementation.
\end{lemma}

\begin{proof}
The comparator has three-level comparison logic that can be made oblivious:
\begin{enumerate}
\item \textbf{Access pattern}: Always read both elements' $\fieldtype$ and $\fieldindex$ fields.
\item \textbf{Arithmetic conversion}: Convert the three-level priority system:
\begin{align}
\text{is\_target}_1 &= (e_1.\fieldtype \in \{\typestart, \typeend\}) \in \{0,1\} \nonumber \\
\text{is\_target}_2 &= (e_2.\fieldtype \in \{\typestart, \typeend\}) \in \{0,1\} \nonumber \\
\text{type\_priority} &= \text{is\_target}_2 - \text{is\_target}_1 \in \{-1, 0, 1\} \nonumber \\
\text{idx\_cmp} &= \text{sign}(e_1.\fieldindex - e_2.\fieldindex) \in \{-1, 0, 1\} \nonumber \\
\text{is\_start}_1 &= (e_1.\fieldtype == \typestart) \in \{0,1\} \nonumber \\
\text{is\_start}_2 &= (e_2.\fieldtype == \typestart) \in \{0,1\} \nonumber \\
\text{start\_first} &= \text{is\_start}_1 - \text{is\_start}_2 \in \{-1, 0, 1\} \nonumber \\
\text{same\_priority} &= (\text{type\_priority} == 0) \in \{0,1\} \nonumber \\
\text{same\_index} &= (\text{idx\_cmp} == 0) \in \{0,1\} \nonumber \\
\text{result} &= (1 - \text{same\_priority}) \cdot \text{type\_priority} \nonumber \\
&\quad + \text{same\_priority} \cdot (1 - \text{same\_index}) \cdot \text{idx\_cmp} \nonumber \\
&\quad + \text{same\_priority} \cdot \text{same\_index} \cdot \text{start\_first} \nonumber
\end{align}
\end{enumerate}
Priority order: (1) Target entries before SOURCE, (2) by original index, (3) START before END.
\end{proof}

\subsection{Update Functions}

\begin{lemma}
\label{lem:update-target-mult}
\textsc{UpdateTargetMultiplicity} (Algorithm~\ref{alg:update-target-multiplicity}) is inherently oblivious.
\end{lemma}

\begin{proof}
The function performs pure arithmetic:
\begin{enumerate}
\item \textbf{Access pattern}: Always read from both $t$ and $e$, always write to $t.\localmult$.
\item \textbf{No conversion needed}: The multiplication $t.\localmult \times e.\localinterval$ is already oblivious.
\end{enumerate}
\end{proof}

\begin{lemma}
\label{lem:update-target-final}
\textsc{UpdateTargetFinalMultiplicity} (Algorithm~\ref{alg:update-target-final}) is inherently oblivious.
\end{lemma}

\begin{proof}
The function performs pure arithmetic:
\begin{enumerate}
\item \textbf{Access pattern}: Always read $e.\foreigninterval$, $e.\foreignsum$, and $t.\localmult$, always write to $t.\finalmult$ and $t.\foreignsum$.
\item \textbf{No conversion needed}: The operations $t.\finalmult = e.\foreigninterval \times t.\localmult$ and $t.\foreignsum = e.\foreignsum$ are pure arithmetic/assignment.
\end{enumerate}
\end{proof}

%----------------------------------------------------------------------
\section{Level 2: Composed Operation Security}
%----------------------------------------------------------------------

Having shown that our base components can be converted to oblivious implementations, we now prove that composing these converted oblivious versions with established oblivious primitives yields oblivious operations.

\subsection{Oblivious Primitives}

We rely on the following well-established oblivious primitives:

\begin{assumption}
\label{assum:primitives}
The following operations are oblivious:
\begin{itemize}
\item \textsc{ObliviousSort}: Uses Batcher's bitonic sort~\cite{batcher1968} with a fixed comparison network
\item \textsc{ObliviousExpand}: From ODBJ~\cite{krastnikov2020}, expands tables obliviously
\item \textsc{LinearPass}: Iterates through a table with fixed window size 2
\item \textsc{ParallelPass}: Applies a function to each element independently
\item \textsc{Map}: Transforms each element independently
\end{itemize}
\end{assumption}

\subsection{Composed Operations}

\begin{lemma}
\label{lem:sort-with-comparator}
For any comparator $C$ that can be converted to oblivious form, \textsc{ObliviousSort}$(T, C_{oblivious})$ is oblivious.
\end{lemma}

\begin{proof}
By Assumption~\ref{assum:primitives}, \textsc{ObliviousSort} has a fixed comparison pattern based only on table size. By Lemmas~\ref{lem:comparator-join}-\ref{lem:comparator-pairwise}, our comparators can be converted to oblivious implementations. Using the converted oblivious versions $C_{oblivious}$ and applying Theorem~\ref{thm:composition}, the composition is oblivious.\end{proof}

\begin{lemma}
\label{lem:linear-with-window}
For any window function $W$ that can be converted to oblivious form, \textsc{LinearPass}$(T, W_{oblivious})$ is oblivious.
\end{lemma}

\begin{proof}
\textsc{LinearPass} has a deterministic iteration pattern based only on table size (with fixed window size 2). By Lemmas~\ref{lem:window-local-sum}-\ref{lem:window-foreign-interval}, our window functions can be converted to oblivious implementations. Using the converted versions $W_{oblivious}$ and applying Theorem~\ref{thm:composition}, the composition is oblivious.\end{proof}

\begin{lemma}
\label{lem:parallel-with-update}
For any update function $U$ that is inherently oblivious or can be converted to oblivious form, \textsc{ParallelPass}$(T, U_{oblivious})$ is oblivious.
\end{lemma}

\begin{proof}
\textsc{ParallelPass} applies $U$ to each element independently with a fixed access pattern. By Lemmas~\ref{lem:update-target-mult}-\ref{lem:update-target-final}, our update functions are inherently oblivious (pure arithmetic). The parallel application maintains obliviousness.\end{proof}

%----------------------------------------------------------------------
\section{Level 3: Phase Security}
%----------------------------------------------------------------------

We prove that each phase of our algorithm is oblivious.

\subsection{Initialization Phase}

\begin{lemma}
\label{lem:init-oblivious}
The Initialization phase (Algorithm~\ref{alg:initialize}) is oblivious.
\end{lemma}

\begin{proof}
Initialization consists of:
\begin{enumerate}
\item \textsc{Map} to add metadata columns
\item \textsc{LinearPass} with \textsc{WindowSetOriginalIndex} (Algorithm~\ref{alg:window-set-orig-index})
\end{enumerate}
Both operations access each element exactly once in a predetermined order. By Theorem~\ref{thm:composition}, their composition is oblivious.\end{proof}

\subsection{Bottom-Up Phase}

\begin{lemma}
\label{lem:bottom-up-oblivious}
The Bottom-Up phase is oblivious.
\end{lemma}

\begin{proof}
For each node in post-order (public tree structure), the phase performs (Algorithm~\ref{alg:compute-local}):
\begin{align}
\text{BottomUp} = &\text{ CombineTable (Algorithm~\ref{alg:combine-table})} \nonumber \\
&\rightarrow \text{ObliviousSort(ComparatorJoinAttr)} \nonumber \\
&\rightarrow \text{LinearPass(WindowComputeLocalSum)} \nonumber \\
&\rightarrow \text{ObliviousSort(ComparatorPairwise)} \nonumber \\
&\rightarrow \text{LinearPass(WindowComputeLocalInterval)} \nonumber \\
&\rightarrow \text{ObliviousSort(ComparatorEndFirst)} \nonumber \\
&\rightarrow \text{ParallelPass(UpdateTargetMultiplicity)} \nonumber
\end{align}

Each operation is oblivious by Lemmas~\ref{lem:sort-with-comparator}-\ref{lem:parallel-with-update}. The number of iterations depends only on the public tree structure. By repeated application of Theorem~\ref{thm:composition}, the entire phase is oblivious.\end{proof}

\subsection{Top-Down Phase}

\begin{lemma}
\label{lem:top-down-oblivious}
The Top-Down phase is oblivious.
\end{lemma}

\begin{proof}
The structure mirrors the Bottom-Up phase but with pre-order traversal and different window/update functions (Algorithm~\ref{alg:propagate-final}). Each component operation is oblivious by the same arguments. By Theorem~\ref{thm:composition}, the phase is oblivious.\end{proof}

\subsection{Distribution and Expansion Phase}

\begin{lemma}
\label{lem:expand-oblivious}
The Distribution and Expansion phase is oblivious.
\end{lemma}

\begin{proof}
This phase applies \textsc{ObliviousExpand} to each table. By Assumption~\ref{assum:primitives}, \textsc{ObliviousExpand} is oblivious. The operation is applied to each table independently based on the public tree structure.\end{proof}

\subsection{Alignment and Concatenation Phase}

\begin{lemma}
\label{lem:align-oblivious}
The Alignment and Concatenation phase is oblivious.
\end{lemma}

\begin{proof}
For each parent-child pair, the phase performs:
\begin{enumerate}
\item \textsc{ObliviousSort} on parent table
\item \textsc{ParallelPass} to compute alignment keys
\item \textsc{ObliviousSort} on child table
\item \textsc{HorizontalConcatenate}
\end{enumerate}
Each operation is oblivious, and their composition is oblivious by Theorem~\ref{thm:composition}.\end{proof}

%----------------------------------------------------------------------
\section{Level 4: Complete Algorithm Security}
%----------------------------------------------------------------------

We now prove our main security theorem.

\begin{proof}[Proof of Theorem~\ref{thm:main-security}]
The complete algorithm performs:
\begin{align}
\text{Algorithm} = &\text{ Initialization} \nonumber \\
&\rightarrow \text{Bottom-Up Phase} \nonumber \\
&\rightarrow \text{Top-Down Phase} \nonumber \\
&\rightarrow \text{Distribution \& Expansion} \nonumber \\
&\rightarrow \text{Alignment \& Concatenation} \nonumber
\end{align}

By Lemmas~\ref{lem:init-oblivious}, \ref{lem:bottom-up-oblivious}, \ref{lem:top-down-oblivious}, \ref{lem:expand-oblivious}, and \ref{lem:align-oblivious}, each phase is oblivious.

By repeated application of Theorem~\ref{thm:composition} (sequential composition), the complete algorithm is oblivious.

Therefore, for any two sets of input tables with the same sizes, tree structure, and output size, the memory access patterns are identically distributed, revealing no information about the actual data values, join selectivities, or which tuples match.\end{proof}

%----------------------------------------------------------------------
\section{Memory Access Pattern Analysis}
%----------------------------------------------------------------------

\textit{[This section is reserved for detailed analysis of memory access patterns and will be completed in future work.]}

%----------------------------------------------------------------------
\section{Summary}
%----------------------------------------------------------------------

We have proven that our oblivious multi-way band join algorithm maintains complete data obliviousness through a modular security proof. The proof builds from simple oblivious components (window functions, comparators, update functions) through composed operations and phases, ultimately establishing that the complete algorithm reveals no information through its memory access patterns beyond what is explicitly allowed (table sizes and tree structure).

The security guarantee holds even for band joins with inequality constraints, where the number of matching tuples and the distribution of values within ranges remain completely hidden from any adversary observing the execution.