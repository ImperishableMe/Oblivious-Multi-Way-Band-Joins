enclave {
    include "enclave_types.h"
    include "crypto/entry_crypto.h"
    
    from "sgx_tstdc.edl" import *;
    
    trusted {
        /* Transform functions for Map operations */
        
        // Initialize leaf multiplicities (set local_mult = 1)
        public void ecall_transform_initialize_leaf([in,out] entry_t* entry);
        
        // Add metadata columns with null placeholders
        public void ecall_transform_add_metadata([in,out] entry_t* entry);
        
        // Set original index (used with sequential counter)
        public void ecall_transform_set_index([in,out] entry_t* entry, uint32_t index);
        
        // Initialize temporary fields for bottom-up computation
        public void ecall_transform_init_local_temps([in,out] entry_t* entry);
        
        // Create SOURCE entry from source table tuple
        public void ecall_transform_to_source([in,out] entry_t* entry);
        
        // Create START entry from target table tuple
        public void ecall_transform_to_start([in,out] entry_t* entry, 
                                             int32_t deviation, 
                                             equality_type_t equality);
        
        // Create END entry from target table tuple
        public void ecall_transform_to_end([in,out] entry_t* entry,
                                           int32_t deviation,
                                           equality_type_t equality);
        
        // Set entry as EMPTY (for padding in oblivious operations)
        public void ecall_transform_set_empty([in,out] entry_t* entry);
        
        /* Window functions for multiplicity computation */
        
        // Assign sequential indices during initialization
        public void ecall_window_set_original_index([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Bottom-up phase: accumulate local multiplicities
        public void ecall_window_compute_local_sum([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Bottom-up phase: compute difference between START/END pairs
        public void ecall_window_compute_local_interval([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Top-down phase: track foreign and local weight counters
        public void ecall_window_compute_foreign_sum([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Top-down phase: compute foreign multiplicity from cumulative sums
        public void ecall_window_compute_foreign_interval([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Bottom-up parallel: multiply local_mult by computed interval
        public void ecall_update_target_multiplicity([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Top-down parallel: set final_mult and foreign_sum
        public void ecall_update_target_final_multiplicity([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        /* Comparator functions for oblivious sorting */
        
        // Sort by join attribute, then precedence
        public void ecall_comparator_join_attr([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Group TARGET entries, then by original_index
        public void ecall_comparator_pairwise([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // END entries first, then by original_index
        public void ecall_comparator_end_first([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Sort by join attribute, then original_index
        public void ecall_comparator_join_then_other([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Sort by original_index only
        public void ecall_comparator_original_index([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        // Sort by alignment_key field
        public void ecall_comparator_alignment_key([in,out] entry_t* e1, [in,out] entry_t* e2);
        
        /* AES-CTR Encryption/Decryption functions */
        /* The encryption key is stored securely inside the enclave and never exposed */
        /* Uses AES-128 in CTR mode with unique nonce for each encryption */
        
        // Encrypt/decrypt single entry using secure enclave-only key
        // Process one entry at a time for memory efficiency in SGX
        public crypto_status_t ecall_encrypt_entry([in,out] entry_t* entry);
        public crypto_status_t ecall_decrypt_entry([in,out] entry_t* entry);
    };
    
    untrusted {
        /* Debug output ocall for enclave debugging */
        void ocall_debug_print(uint32_t level, [in, string] const char* file, 
                              int line, [in, string] const char* message);
    };
};