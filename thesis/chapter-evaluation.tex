%======================================================================
\chapter{Evaluation}
%======================================================================

We evaluate our oblivious multi-way band join algorithm by comparing its performance against OJOIN~\cite{hu2025optimal}, the state-of-the-art oblivious multi-way join algorithm. Our experiments use the same TPC-H benchmark setup to ensure a fair comparison, focusing on both multi-way equality joins and band joins with inequality constraints.

%----------------------------------------------------------------------
\section{Implementation}
%----------------------------------------------------------------------

We implemented our algorithm in C++ for Intel SGX2.

\subsection{Data Preprocessing}

To simplify the implementation and focus on the core algorithmic performance, we preprocess the TPC-H tables as follows:

\begin{itemize}
\item \textbf{Type conversion}: All date and string fields are converted to integers. Dates are represented as days since a reference date (1970-01-01), while strings are mapped to integer identifiers through a preprocessing dictionary.

\item \textbf{Table duplication}: When a query requires using the same table multiple times (self-joins or multiple references), we create distinct copies with appropriate renaming. This simplifies the tree structure handling without affecting the algorithm's complexity.

\item \textbf{Memory layout}: Tables are stored as arrays of row objects within the enclave. This row-oriented storage is a source of performance overhead compared to column-oriented formats that would better match our sequential access patterns.
\end{itemize}


%----------------------------------------------------------------------
\section{Experimental Setup}
%----------------------------------------------------------------------

\subsection{Dataset and Queries}

We use the TPC-H benchmark with scale factor 0.1 (SF=0.1), matching the setup used in the OJOIN~\cite{hu2025optimal} evaluation. This generates approximately 100MB of raw data across eight tables. We evaluate pure \texttt{SELECT-FROM-WHERE} queries without subqueries or aggregation operations, focusing on the core join performance. The queries from the OJOIN~\cite{hu2025optimal} paper are:

\textbf{Multi-way Equality Joins (TM series):}
\begin{itemize}
\item \textbf{TM1}: 3-way join between \texttt{lineitem}, \texttt{orders}, and \texttt{customer}
\item \textbf{TM2}: 4-way join between \texttt{lineitem}, \texttt{orders}, \texttt{customer}, and \texttt{nation}
\item \textbf{TM3}: 5-way join adding \texttt{region} to TM2
\end{itemize}

\textbf{Band Joins (TB series):}
\begin{itemize}
\item \textbf{TB1}: Band join query with date range constraints on \texttt{lineitem}
\item \textbf{TB2}: Extended band join with overlapping date ranges across \texttt{lineitem} and \texttt{orders}
\end{itemize}

All queries follow the standard SQL pattern without \texttt{GROUP BY}, \texttt{HAVING}, subqueries, or aggregate functions. This allows us to focus purely on the join algorithm performance without the complexity of aggregation processing.

The specific band join queries tested are:

\textbf{TB1 Query:}
\begin{verbatim}
SELECT * FROM lineitem, orders
WHERE l_orderkey = o_orderkey
  AND l_shipdate >= o_orderdate
  AND l_shipdate <= o_orderdate + 30
\end{verbatim}

\textbf{TB2 Query:}
\begin{verbatim}
SELECT * FROM lineitem l1, lineitem l2, orders
WHERE l1.l_orderkey = o_orderkey
  AND l2.l_orderkey = o_orderkey
  AND l1.l_shipdate >= o_orderdate
  AND l1.l_shipdate <= o_orderdate + 30
  AND l2.l_shipdate >= o_orderdate + 15
  AND l2.l_shipdate <= o_orderdate + 45
\end{verbatim}

These queries test band join performance with date range constraints, where TB1 performs a single band join and TB2 involves overlapping date ranges across multiple joins.

\subsection{Hardware Configuration}

Experiments were conducted on a server with the following specifications:
\begin{itemize}
\item Intel Xeon E-2374G processor @ 3.70GHz with SGX support
\item 4 cores, 8 threads with AVX-512 support
\item 125GB RAM (120GB available)
\item Ubuntu 22.04.4 LTS with Linux kernel 5.15.0
\item NVMe SSD storage
\end{itemize}

\subsection{Metrics}

We measure the total execution time for each query, comparing our algorithm's runtime against OJOIN~\cite{hu2025optimal}.

%----------------------------------------------------------------------
\section{Results: Multi-way Equality Joins}
%----------------------------------------------------------------------

Table~\ref{tab:equality-joins} shows the performance comparison between our algorithm and OJOIN~\cite{hu2025optimal} for multi-way equality joins.

\begin{table}[h]
\centering
\caption{Performance comparison for multi-way equality joins}
\label{tab:equality-joins}
\begin{tabular}{llrrrr}
\toprule
Query & Scale Factor & Output Size & OJOIN (s) & Ours (s) & Speedup \\
\midrule
TM2 & 0.001 & 292 & -- & 0.77 & -- \\
TM2 & 0.01 & 29,929 & 10 & 10.38 & 0.96× \\
TM2 & 0.1 & 2,999,594 & 100 & OOM\footnotemark & -- \\
\bottomrule
\end{tabular}
\end{table}
\footnotetext{Out of memory error due to large output size (3M rows) exceeding enclave heap limit}

For TM2 at scale factor 0.01, our algorithm performs comparably to OJOIN~\cite{hu2025optimal} with both completing in approximately 10 seconds. However, at SF=0.1, the output size of nearly 3 million rows exceeds our current 512MB heap limit, while OJOIN completes in 100 seconds.


%----------------------------------------------------------------------
\section{Results: Band Joins}
%----------------------------------------------------------------------

Table~\ref{tab:band-joins} presents the results for band join queries with inequality constraints.

\begin{table}[h]
\centering
\caption{Performance comparison for band joins at different scale factors}
\label{tab:band-joins}
\begin{tabular}{llrrrr}
\toprule
Query & Scale Factor & Output Size & OJOIN (s) & Ours (s) & Speedup \\
\midrule
TB1 & 0.001 & 10 & -- & 2.58 & -- \\
TB1 & 0.01 & 111 & -- & 2.59 & -- \\
TB1 & 0.1 & 2,042 & 100 & 2.95 & 33.9× \\
\midrule
TB2 & 0.001 & 200 & -- & 2.61 & -- \\
TB2 & 0.01 & 4,002 & -- & 3.50 & -- \\
TB2 & 0.1 & 397,380 & 100,000 & OOM\footnotemark & -- \\
\bottomrule
\end{tabular}
\end{table}
\footnotetext{Out of memory error due to large output size (397K rows) exceeding enclave heap limit}

Our dual-entry technique provides significant advantages for band joins. For TB1 at scale factor 0.1, we achieve a remarkable 33.9× speedup over OJOIN~\cite{hu2025optimal}, completing the query in 2.95 seconds compared to OJOIN's 100 seconds. The performance remains consistent across different scale factors, demonstrating the efficiency of our approach.

For TB2, while we successfully process smaller scale factors, the SF=0.1 dataset produces 397,380 output rows which exceeds our current enclave heap limit of 512MB. OJOIN requires 100,000 seconds (over 27 hours) for this query, highlighting the computational challenge of large band joins.



%----------------------------------------------------------------------
\section{Discussion}
%----------------------------------------------------------------------

\subsection{Key Findings}

Our evaluation demonstrates:

\begin{enumerate}
\item \textbf{Exceptional band join performance}: TB1 shows 33.9× speedup over OJOIN~\cite{hu2025optimal} at SF=0.1
\item \textbf{Competitive equality joins}: TM2 performs comparably to OJOIN at SF=0.01
\item \textbf{High SGX overhead on small data}: TB1 runtime remains nearly constant (2.58-2.95s) across scale factors due to SGX enclave overhead dominating on smaller datasets
\item \textbf{Memory limitations}: Large output sizes (TB2: 397K rows, TM2: 3M rows) exceed current 512MB heap limit
\end{enumerate}

\subsection{Future Improvements}

\begin{itemize}
\item \textbf{Selective SGX execution}: Execute only the critical oblivious operations (window functions and comparators) inside SGX while keeping data outside the enclave. This would reduce memory requirements to constant space, enabling processing of arbitrarily large inputs and outputs.
\item \textbf{Columnar storage}: Transition from row-oriented to column-oriented storage for better cache utilization and sequential access patterns.
\item \textbf{Streaming preprocessing}: Integrate type conversion and table preparation into the main algorithm to avoid separate preprocessing passes.
\item \textbf{Cyclic query support}: Extend the algorithm to handle cyclic join graphs using generalized hypertree decomposition.
\end{itemize}

%----------------------------------------------------------------------
\section{Summary}
%----------------------------------------------------------------------

Our oblivious multi-way band join algorithm demonstrates substantial performance improvements over the state-of-the-art OJOIN~\cite{hu2025optimal} algorithm, particularly for band join queries. For TB1 at scale factor 0.1, we achieve a remarkable 33.9× speedup, reducing execution time from 100 seconds to just 2.95 seconds. For equality joins like TM2, we achieve comparable performance at smaller scale factors. The dual-entry technique proves highly effective for handling inequality constraints while maintaining complete data obliviousness. While memory constraints limit processing of very large result sets (millions of output rows), our implementation in SGX demonstrates the practicality of our approach for secure database applications.