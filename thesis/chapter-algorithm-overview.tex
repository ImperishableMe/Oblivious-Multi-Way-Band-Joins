%======================================================================
\chapter{Algorithm Overview}
%======================================================================

This chapter provides an intuitive overview of our algorithm before diving into formal specifications. We begin with \odbj's~\cite{krastnikov2020} binary join solution, which separates multiplicity computation from result construction. We then explain how to extend this to multi-way joins by computing multiplicities recursively through tree traversals---a structure that surprisingly mirrors Yannakakis'~\cite{yannakakis1981} classical algorithm. Finally, we introduce our dual-entry technique that enables these computations to work with band conditions, transforming range matching into simple cumulative sums through sorted sequences.

%----------------------------------------------------------------------
\section{From \odbj\ to Oblivious Yannakakis}
%----------------------------------------------------------------------

Our work builds upon recent advances in oblivious database operations, extending binary join techniques to handle multi-way joins with band conditions.

\subsection{Starting with \odbj's Architecture}

Krastnikov et al.'s \odbj~\cite{krastnikov2020} provides an elegant solution for oblivious binary joins, achieving $\bigO{\tablesize \log^2 \tablesize + \outputsize \log \outputsize}$ complexity where $\tablesize$ is input size and $\outputsize$ is output size. The \odbj\ architecture can be separated into two distinct parts: multiplicity computation and result construction.

\subsubsection{Multiplicity Computation Phase}

The algorithm begins by combining both \inputtables\ into a single table sorted by the join attribute, with each tuple tagged by its source table. This combined representation enables counting and recording multiplicities. A forward pass through the sorted table counts occurrences of each unique join key, with two counters tracking tuples from $T_1$ and $T_2$. These counts are then propagated backward to ensure every tuple with the same join key receives the complete count information. 

Through this process, each tuple $(j, d)$ is augmented with two metadata values representing the local multiplicities ($\localmult$): $\alpha_1(j)$, the occurrence of key $j$ in $T_1$, and $\alpha_2(j)$, the occurrence in $T_2$. The significance of these local multiplicity values becomes clear when we consider the join result---each tuple from $T_1$ must appear $\alpha_2(j)$ times (once for each match in $T_2$), while each tuple from $T_2$ must appear $\alpha_1(j)$ times. Thus each tuple obtains its own multiplicity for result construction.

\subsubsection{Result Construction Phase}

With multiplicities computed, \odbj\ constructs the actual join result through three oblivious operations. The \textbf{distribute} operation and the \textbf{expand} operation work together to duplicate each tuple by its multiplicity. Then, the \textbf{align} operation reorders one \expandedtable\ to match the other, ensuring that tuples appear at correct locations, ready to be zipped into the binary join result.

This separation means we must obtain the size of the join result, along with multiplicities of all tuples in the join result, before we can duplicate them for the correct number of times or proceed with any further step. For binary joins, \odbj\ demonstrates this can be done obliviously using only sorting networks and linear scans, avoiding expensive primitives like ORAM~\cite{goldreich1996}.

\subsection{The Multi-Way Multiplicity Challenge}

To extend \odbj~\cite{krastnikov2020} to multi-way joins, we must obtain the multiplicity of each tuple in the full join result before constructing it. For binary joins, \odbj~\cite{krastnikov2020} computes this directly. For multi-way joins over a tree structure, the challenge is: how do we compute the final multiplicity of each tuple when it depends on tables across the entire tree?

We start by looking at a smaller picture, joining the subtree for every table, and call the table tuple's multiplicity in this sub-tree join result ``local multiplicity ($\localmult$)''. For a root tuple, local multiplicity is the same as the final multiplicity ($\finalmult$). This ``local multiplicity of root tuples'' can be computed recursively.

We observe that for an arbitrary parent table tuple, its local multiplicity ($\localmult$) is a product of contributions from joining with each of the child tables. The contribution from each child table is the sum of local multiplicities of matching child table tuples. With a bottom-up traversal of the join tree, we can compute local multiplicities $\localmult$ of all root table tuples.

After obtaining the local multiplicities $\localmult$ of the root table tuples, we view them as final multiplicities ($\finalmult$), and we use a top-down join tree traversal to propagate this final multiplicity $\finalmult$ information across the join tree.

We then perform the distribute and expand, alignment and concatenation phases using the multiplicities.

\subsection{Connection to Yannakakis}

Interestingly, our two-phase structure mirrors Yannakakis's algorithm~\cite{yannakakis1981} for acyclic joins. Yannakakis also uses bottom-up semi-join reduction followed by top-down reconstruction. While Yannakakis computes a boolean value for each tuple indicating whether it exists in the join result or not, we count multiplicities for each tuple indicating how many times it exists in the join result.

%----------------------------------------------------------------------
\section{Band Join Enhancement: Dual Entry Approach}
%----------------------------------------------------------------------

\subsection{The Challenge of Range-Based Multiplicity Computation}

The extension from equality joins to band joins introduces a fundamental challenge in multiplicity computation. Consider two tables A and B with band join condition $A.x \geq B.y - c_1$ and $A.x \leq B.y + c_2$. For a tuple from table A with attribute value $A.x = v$, we must sum the local multiplicities of all tuples from table B that satisfy the range constraint. This differs significantly from equality joins where the matching relationship is one-to-one between groups.

In equality joins where $A.x = B.y$, the multiplicity computation is straightforward: we sort the \combinedtables\ by the join attribute and perform a linear pass, summing tuples with identical values and resetting the sum when the join attribute value changes. This direct accumulation works because each tuple matches exactly those tuples with the same join key value.

Band joins complicate this process because each tuple from table A matches all tuples from table B where $v - c_2 \leq B.y \leq v + c_1$. The challenge lies in efficiently computing the sum of multiplicities across this range without revealing information about the data distribution. A naive approach would require examining each possible matching tuple individually, but this would be inefficient and potentially leak information through access patterns.

\subsection{The Dual Entry Solution}

Our solution transforms the range matching problem into a cumulative sum computation through a dual entry technique. For each tuple $t$ in table A with join attribute value $v$, we create two boundary markers: a start entry at position $v - c_2$ representing the smallest possible matching B value, and an end entry at position $v + c_1$ representing the largest possible matching B value. These boundary markers, combined with the actual tuples from table B, are then sorted by their join attribute values to create a unified sequence.

During a single linear pass through this sorted sequence, we maintain a cumulative sum counter ($\cumsum$) that increments by the local multiplicity ($\localmult$) of each tuple from table B. When we reach the start and end boundary markers for a given tuple from table A, we record the current cumulative sum values. The difference between the end counter and start counter gives precisely the sum of local multiplicities $\localmult$ for all table B tuples that fall within the required range.

This dual entry approach transforms a complex range matching problem into a simple interval computation. The key insight is that start and end entries define interval boundaries in the sorted \combinedtable, and the cumulative counter tracks all relevant contributions seen so far. The difference between consecutive boundary markers captures exactly the multiplicities needed for the range-based join. Crucially, this process remains oblivious since all operations rely solely on oblivious sorting and fixed linear passes with predetermined access patterns, ensuring that no information about the actual data values or match counts is leaked through memory access patterns.

