%======================================================================
\chapter{Related Work}
%======================================================================

This chapter reviews the existing literature on oblivious database operations, focusing on join algorithms. We trace the development from binary equi-joins to our target problem of multi-way band joins, identifying the critical gap that our work addresses.

%----------------------------------------------------------------------
\section{Efficient Oblivious Database Join}
%----------------------------------------------------------------------

Krastnikov et al. proposed the first efficient oblivious algorithm for binary database equi-joins. Their algorithm achieves $\bigO{\tablesize \log^2 \tablesize + \outputsize \log \outputsize}$ complexity where $\tablesize$ is input size and $\outputsize$ is output size, matching the standard non-oblivious sort-merge join up to a logarithmic factor.

The key innovation of \odbj\ is using sorting networks and novel provably-oblivious constructions without relying on ORAM. The algorithm operates in two main phases: multiplicity computation and result construction. During multiplicity computation, tables are combined and sorted by join attribute, with linear passes counting occurrences. The result construction phase uses oblivious distribute and expand operations to create the appropriate number of copies of each tuple.

However, \odbj\ is limited to \textbf{equality predicates only} and \textbf{binary joins} (two tables). It serves as the foundational algorithm for oblivious join processing that we extend in this work.

%----------------------------------------------------------------------
\section{Extension to Band Joins (Inequality Constraints)}
%----------------------------------------------------------------------

Chang et al. made two important extensions to oblivious joins:

\begin{enumerate}
\item \textbf{Binary band joins}: They extended Krastnikov's algorithm to support inequality predicates like $T_1.A \geq T_2.B - c_1$ and $T_1.A \leq T_2.B + c_2$. This maintains oblivious access patterns while handling $>, <, \geq, \leq$ predicates between attributes, but is limited to \textbf{binary joins only}.

\item \textbf{Multiway equi-joins}: They use ORAM-based index nested-loop join with B-tree indices to support joins over multiple tables, but only for \textbf{equality predicates}.
\end{enumerate}

The B-tree approach used for multiway equi-joins cannot be extended to support band conditions. While B-trees are efficient for exact key lookups, range queries in the oblivious setting become problematic---accessing a variable number of nodes for range queries would leak information about the data distribution and result size. To maintain obliviousness, one would need to pad accesses to the worst case, essentially scanning entire tables and negating the benefits of using an index. Therefore, no existing algorithm combines multiple tables with inequality predicates obliviously.

%----------------------------------------------------------------------
\section{Multi-Way Joins (Classical Non-Oblivious)}
%----------------------------------------------------------------------

The classical Yannakakis algorithm achieves optimal $\bigO{\inputsize + \outputsize}$ complexity for acyclic multi-way joins in the non-oblivious setting. It uses a two-phase approach:

\begin{enumerate}
\item \textbf{Bottom-up phase}: Semi-join reductions to eliminate tuples that don't contribute to the final result
\item \textbf{Top-down phase}: Result reconstruction by propagating constraints down the tree
\end{enumerate}

This approach eliminates tuples that don't contribute to the final result, bounding runtime by output size. While Yannakakis achieves optimal complexity for acyclic queries, it is \textbf{not oblivious}---the access patterns reveal information about data distribution and intermediate result sizes. Yannakakis serves as the theoretical foundation for optimal multi-way join processing that we aim to make oblivious.

%----------------------------------------------------------------------
\section{Worst-Case Optimal Join Algorithms}
%----------------------------------------------------------------------

Recent work by Hu and Wu~\cite{hu2025optimal} has made significant progress in developing oblivious algorithms for worst-case optimal multi-way joins, representing an important achievement in oblivious multi-way query processing.

Worst-case optimal algorithms optimize for the theoretical upper bound on output size for a given query structure, assuming maximal matches between tuples regardless of actual data content. This ``worst-case'' bound represents the maximum possible output size that could occur for any instance with the given query and input sizes. In contrast, Yannakakis' algorithm---and our approach building upon it---optimizes for the actual output size of the specific data instance. This output-sensitive approach is particularly beneficial when tuples do not exhibit maximal matching patterns.

Our work thus follows a complementary direction to Hu and Wu's approach. Their worst-case optimal algorithm is particularly valuable for cyclic queries where there is no known efficient method to compute the exact output size. In contrast, for acyclic queries, the exact output size can be efficiently computed, allowing our oblivious Yannakakis-based approach to achieve $\optimalcomplexity$ complexity on acyclic queries, where $\outputsize$ is the actual output size.

%----------------------------------------------------------------------
\section{Critical Gap in the Literature}
%----------------------------------------------------------------------

The existing literature reveals a critical gap: \textbf{No existing solution combines multi-way joins with band conditions obliviously}. 

Table~\ref{tab:related-work-comparison} summarizes the capabilities of existing approaches:

\begin{table}[ht]
\centering
\caption{Comparison of Existing Oblivious Join Approaches}
\label{tab:related-work-comparison}
\begin{tabular}{|p{4cm}|c|c|c|c|}
\hline
\textbf{Approach} & \textbf{Binary} & \textbf{Multi-way} & \textbf{Equality} & \textbf{Band} \\
\hline
\odbj\ (Krastnikov et al.) & \checkmark & & \checkmark & \\
\hline
Chang et al. (binary) & \checkmark & & \checkmark & \checkmark \\
\hline
Opaque/ObliDB & & \checkmark & \checkmark & \\
\hline
Chang et al. (multi-way) & & \checkmark & \checkmark & \\
\hline
Hu and Wu (WCO) & & \checkmark & \checkmark & \\
\hline
\textbf{Our Work} & \checkmark & \checkmark & \checkmark & \checkmark \\
\hline
\end{tabular}
\end{table}

Opaque uses oblivious sort-merge join but is limited to primary-foreign key joins~\cite{opaque2017}. ObliDB supports general multi-way joins using hash join, but this approach essentially computes the Cartesian product, leading to poor performance~\cite{oblidb2020, chang2022}. Hash-based join methods are particularly unsuitable for extension to range queries, as they rely on exact key matching rather than ordering. 

A critical limitation of performing multi-way joins as a series of oblivious binary joins is that it discloses intermediate table sizes, leaking sensitive information about the data distribution and selectivity.

%----------------------------------------------------------------------
\section{Our Approach: Bridging the Gap}
%----------------------------------------------------------------------

Our work bridges this gap by implementing an \textbf{oblivious Yannakakis algorithm} that supports both \textbf{multi-way joins} and \textbf{band conditions}. We achieve this by:

\begin{itemize}
\item Using \textbf{\textsc{odbj} as the base algorithm} for processing neighboring table pairs in the join tree

\item Extending oblivious Yannakakis to support \textbf{inequality predicates} through a novel dual-entry technique

\item Achieving $\optimalcomplexity$ complexity for acyclic queries with full band join support

\item Being the \textbf{first algorithm} to combine efficient oblivious multi-way processing with general range constraints
\end{itemize}

This approach maintains the optimal complexity of Yannakakis (up to logarithmic factors) while supporting the full generality of band conditions, all within the oblivious computation model.